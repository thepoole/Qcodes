<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qcodes.instrument.parameter &mdash; QCoDeS 0.30.0.dev0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href="../../../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> QCoDeS
          </a>
              <div class="version">
                0.30.0.dev0+433.gef36c42fa
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../start/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../help.html">Get Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/index.html">Community Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dataset/index.html">DataSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">QCoDes API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/generated/qcodes.instrument_drivers.html">qcodes.instrument_drivers package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changes/index.html">Changelogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples of using QCoDeS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QCoDeS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>qcodes.instrument.parameter</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qcodes.instrument.parameter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The Parameter module implements Parameter interface</span>
<span class="sd">that are the basis of measurements and control within QCoDeS.</span>

<span class="sd">Anything that you want to either measure or control within QCoDeS should</span>
<span class="sd">satisfy the Parameter interface. Most of the time that is easiest to do</span>
<span class="sd">by either using or subclassing one of the classes defined here, but you can</span>
<span class="sd">also use any class with the right attributes.</span>

<span class="sd">All parameter classes are subclassed from ``._BaseParameter`` (except</span>
<span class="sd">CombinedParameter). The _BaseParameter provides functionality that is common</span>
<span class="sd">to all parameter types, such as ramping and scaling of values, adding delays</span>
<span class="sd">(see documentation for details).</span>

<span class="sd">This module defines the following basic classes of parameters as well as some</span>
<span class="sd">more specialized ones:</span>

<span class="sd">- :class:`.Parameter` is the base class for scalar-valued parameters.</span>
<span class="sd">    Two primary ways in which it can be used:</span>

<span class="sd">    1. As an :class:`.Instrument` parameter that sends/receives commands.</span>
<span class="sd">       Provides a standardized interface to construct strings to pass to the</span>
<span class="sd">       :meth:`.Instrument.write` and :meth:`.Instrument.ask` methods</span>
<span class="sd">    2. As a variable that stores and returns a value. For instance, for storing</span>
<span class="sd">       of values you want to keep track of but cannot set or get electronically.</span>

<span class="sd">- :class:`.ParameterWithSetpoints` is intended for array-values parameters.</span>
<span class="sd">    This Parameter class is intended for anything where a call to the instrument</span>
<span class="sd">    returns an array of values. `This notebook</span>
<span class="sd">    &lt;../../examples/Parameters/Simple-Example-of-ParameterWithSetpoints</span>
<span class="sd">    .ipynb&gt;`_ gives more detailed examples of how this parameter</span>
<span class="sd">    can be used `and this notebook</span>
<span class="sd">    &lt;../../examples/writing_drivers/A-ParameterWithSetpoints</span>
<span class="sd">    -Example-with-Dual-Setpoints.ipynb&gt;`_ explains writing driver</span>
<span class="sd">    using :class:`.ParameterWithSetpoints`.</span>

<span class="sd">    :class:`.ParameterWithSetpoints` is supported in a</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement` but is not supported by</span>
<span class="sd">    the legacy :class:`qcodes.loops.Loop` and :class:`qcodes.measure.Measure`</span>
<span class="sd">    measurement types.</span>

<span class="sd">- :class:`.DelegateParameter` is intended for proxy-ing other parameters.</span>
<span class="sd">    It forwards its ``get`` and ``set`` to the underlying source parameter,</span>
<span class="sd">    while allowing to specify label/unit/etc that is different from the</span>
<span class="sd">    source parameter.</span>

<span class="sd">- :class:`.ArrayParameter` is an older base class for array-valued parameters.</span>
<span class="sd">    For any new driver we strongly recommend using</span>
<span class="sd">    :class:`.ParameterWithSetpoints` which is both more flexible and</span>
<span class="sd">    significantly easier to use. This Parameter is intended for anything for</span>
<span class="sd">    which each ``get`` call returns an array of values that all have the same</span>
<span class="sd">    type and meaning. Currently not settable, only gettable. Can be used in a</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement`</span>
<span class="sd">    as well as in the legacy :class:`qcodes.loops.Loop`</span>
<span class="sd">    and :class:`qcodes.measure.Measure` measurements - in which case</span>
<span class="sd">    these arrays are nested inside the loop&#39;s setpoint array. To use, provide a</span>
<span class="sd">    ``get`` method that returns an array or regularly-shaped sequence, and</span>
<span class="sd">    describe that array in ``super().__init__``.</span>

<span class="sd">- :class:`.MultiParameter` is the base class for multi-valued parameters.</span>
<span class="sd">    Currently not settable, only gettable, but can return an arbitrary</span>
<span class="sd">    collection of scalar and array values and can be used in</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement` as well as the</span>
<span class="sd">    legacy :class:`qcodes.loops.Loop` and :class:`qcodes.measure.Measure`</span>
<span class="sd">    measurements. To use, provide a ``get`` method</span>
<span class="sd">    that returns a sequence of values, and describe those values in</span>
<span class="sd">    ``super().__init__``.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># TODO (alexcjohnson) update this with the real duck-typing requirements or</span>
<span class="c1"># create an ABC for Parameter and MultiParameter - or just remove this statement</span>
<span class="c1"># if everyone is happy to use these classes.</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">xor</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">TracebackType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Sized</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Protocol</span>

<span class="kn">from</span> <span class="nn">qcodes.data.data_array</span> <span class="kn">import</span> <span class="n">DataArray</span>
<span class="kn">from</span> <span class="nn">qcodes.instrument.sweep_values</span> <span class="kn">import</span> <span class="n">SweepFixedValues</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.command</span> <span class="kn">import</span> <span class="n">Command</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.deprecate</span> <span class="kn">import</span> <span class="n">deprecate</span><span class="p">,</span> <span class="n">issue_deprecation_warning</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.helpers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DelegateAttributes</span><span class="p">,</span>
    <span class="n">abstractmethod</span><span class="p">,</span>
    <span class="n">full_class</span><span class="p">,</span>
    <span class="n">is_sequence_of</span><span class="p">,</span>
    <span class="n">named_repr</span><span class="p">,</span>
    <span class="n">permissive_range</span><span class="p">,</span>
    <span class="n">warn_units</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.metadata</span> <span class="kn">import</span> <span class="n">Metadatable</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.validators</span> <span class="kn">import</span> <span class="n">Arrays</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Ints</span><span class="p">,</span> <span class="n">Strings</span><span class="p">,</span> <span class="n">Validator</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Instrument</span><span class="p">,</span> <span class="n">InstrumentBase</span>


<span class="c1"># for now the type the parameter may contain is not restricted at all</span>
<span class="n">ParamDataType</span> <span class="o">=</span> <span class="n">Any</span>
<span class="n">ParamRawDataType</span> <span class="o">=</span> <span class="n">Any</span>


<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_SetParamContext</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is returned by the ``set_to`` method of parameter</span>

<span class="sd">    Example usage:</span>

<span class="sd">    &gt;&gt;&gt; v = dac.voltage()</span>
<span class="sd">    &gt;&gt;&gt; with dac.voltage.set_to(-1):</span>
<span class="sd">        ...     # Do stuff with the DAC output set to -1 V.</span>
<span class="sd">        ...</span>
<span class="sd">    &gt;&gt;&gt; assert abs(dac.voltage() - v) &lt;= tolerance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">:</span> <span class="s2">&quot;_BaseParameter&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span>
                 <span class="n">allow_changes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span> <span class="o">=</span> <span class="n">parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allow_changes</span> <span class="o">=</span> <span class="n">allow_changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_settable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_changes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_original_settable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">settable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_settable</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># type: ignore[has-type]</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">typ</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">]],</span>
                 <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">],</span>
                 <span class="n">traceback</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TracebackType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_changes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_settable</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># type: ignore[has-type]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_original_settable</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_value</span><span class="p">)</span>


<div class="viewcode-block" id="invert_val_mapping"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.invert_val_mapping">[docs]</a><span class="k">def</span> <span class="nf">invert_val_mapping</span><span class="p">(</span><span class="n">val_mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Inverts the value mapping dictionary for allowed parameter values&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<span class="k">class</span> <span class="nc">_BaseParameter</span><span class="p">(</span><span class="n">Metadatable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shared behavior for all parameters. Not intended to be used</span>
<span class="sd">    directly, normally you should use ``Parameter``, ``ArrayParameter``,</span>
<span class="sd">    ``MultiParameter``, or ``CombinedParameter``.</span>
<span class="sd">    Note that ``CombinedParameter`` is not yet a subclass of ``_BaseParameter``</span>

<span class="sd">    Args:</span>
<span class="sd">        name: the local name of the parameter. Must be a valid</span>
<span class="sd">            identifier, ie no spaces or special characters or starting with a</span>
<span class="sd">            number. If this parameter is part of an Instrument or Station,</span>
<span class="sd">            this should match how it will be referenced from that parent,</span>
<span class="sd">            ie ``instrument.name`` or ``instrument.parameters[name]``</span>

<span class="sd">        instrument: the instrument this parameter</span>
<span class="sd">            belongs to, if any</span>

<span class="sd">        snapshot_get: False prevents any update to the</span>
<span class="sd">            parameter during a snapshot, even if the snapshot was called with</span>
<span class="sd">            ``update=True``, for example if it takes too long to update.</span>
<span class="sd">            Default True.</span>

<span class="sd">        snapshot_value: False prevents parameter value to be</span>
<span class="sd">            stored in the snapshot. Useful if the value is large.</span>

<span class="sd">        snapshot_exclude: True prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>
<span class="sd">            Default False</span>

<span class="sd">        step: max increment of parameter value.</span>
<span class="sd">            Larger changes are broken into multiple steps this size.</span>
<span class="sd">            When combined with delays, this acts as a ramp.</span>

<span class="sd">        scale: Scale to multiply value with before</span>
<span class="sd">            performing set. the internally multiplied value is stored in</span>
<span class="sd">            ``cache.raw_value``. Can account for a voltage divider.</span>

<span class="sd">        offset: Compensate for a parameter specific offset. (just as scale)</span>
<span class="sd">            get value = raw value - offset.</span>
<span class="sd">            set value = argument + offset.</span>
<span class="sd">            If offset and scale are used in combination, when getting a value,</span>
<span class="sd">            first an offset is added, then the scale is applied.</span>

<span class="sd">        inter_delay: Minimum time (in seconds) between successive sets.</span>
<span class="sd">            If the previous set was less than this, it will wait until the</span>
<span class="sd">            condition is met. Can be set to 0 to go maximum speed with</span>
<span class="sd">            no errors.</span>

<span class="sd">        post_delay: time (in seconds) to wait after the *start* of each set,</span>
<span class="sd">            whether part of a sweep or not. Can be set to 0 to go maximum</span>
<span class="sd">            speed with no errors.</span>

<span class="sd">        val_mapping: A bidirectional map data/readable values to instrument</span>
<span class="sd">            codes, expressed as a dict: ``{data_val: instrument_code}``</span>
<span class="sd">            For example, if the instrument uses &#39;0&#39; to mean 1V and &#39;1&#39; to mean</span>
<span class="sd">            10V, set val_mapping={1: &#39;0&#39;, 10: &#39;1&#39;} and on the user side you</span>
<span class="sd">            only see 1 and 10, never the coded &#39;0&#39; and &#39;1&#39;</span>
<span class="sd">            If vals is omitted, will also construct a matching Enum validator.</span>
<span class="sd">            NOTE: only applies to get if get_cmd is a string, and to set if</span>
<span class="sd">            set_cmd is a string.</span>
<span class="sd">            You can use ``val_mapping`` with ``get_parser``, in which case</span>
<span class="sd">            ``get_parser`` acts on the return value from the instrument first,</span>
<span class="sd">            then ``val_mapping`` is applied (in reverse).</span>

<span class="sd">        get_parser: Function to transform the response from get to the final</span>
<span class="sd">            output value. See also val_mapping</span>

<span class="sd">        set_parser: Function to transform the input set value to an encoded</span>
<span class="sd">            value sent to the instrument. See also val_mapping.</span>

<span class="sd">        vals: a Validator object for this parameter</span>

<span class="sd">        max_val_age: The max time (in seconds) to trust a saved value obtained</span>
<span class="sd">            from ``cache.get`` (or ``get_latest``). If this parameter has not</span>
<span class="sd">            been set or measured more recently than this, perform an</span>
<span class="sd">            additional measurement.</span>

<span class="sd">        metadata: extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter</span>

<span class="sd">        abstract: Specifies if this parameter is abstract or not. Default</span>
<span class="sd">            is False. If the parameter is &#39;abstract&#39;, it *must* be overridden</span>
<span class="sd">            by a non-abstract parameter before the instrument containing</span>
<span class="sd">            this parameter can be instantiated. We override a parameter by</span>
<span class="sd">            adding one with the same name and unit. An abstract parameter</span>
<span class="sd">            can be added in a base class and overridden in a subclass.</span>

<span class="sd">        bind_to_instrument: Should the parameter be registered as a delegate attribute</span>
<span class="sd">            on the instrument passed via the instrument argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;InstrumentBase&quot;</span><span class="p">],</span>
        <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inter_delay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">post_delay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">val_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">get_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">set_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">snapshot_exclude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_val_age</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Validator</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bind_to_instrument</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter name must be a valid identifier &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> which is not. Parameter names &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;cannot start with a number and &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;must not contain spaces or special characters&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span> <span class="o">=</span> <span class="n">instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_get</span> <span class="o">=</span> <span class="n">snapshot_get</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span> <span class="o">=</span> <span class="n">snapshot_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_exclude</span> <span class="o">=</span> <span class="n">snapshot_exclude</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="n">Validator</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;vals must be None or a Validator&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">val_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="o">*</span><span class="n">val_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span> <span class="o">=</span> <span class="n">inter_delay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_delay</span> <span class="o">=</span> <span class="n">post_delay</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">val_mapping</span> <span class="o">=</span> <span class="n">val_mapping</span>
        <span class="k">if</span> <span class="n">val_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span> <span class="o">=</span> <span class="n">invert_val_mapping</span><span class="p">(</span><span class="n">val_mapping</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">get_parser</span> <span class="o">=</span> <span class="n">get_parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parser</span> <span class="o">=</span> <span class="n">set_parser</span>

        <span class="c1"># ``_Cache`` stores &quot;latest&quot; value (and raw value) and timestamp</span>
        <span class="c1"># when it was set or measured</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span> <span class="n">_CacheProtocol</span> <span class="o">=</span> <span class="n">_Cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_val_age</span><span class="o">=</span><span class="n">max_val_age</span><span class="p">)</span>
        <span class="c1"># ``GetLatest`` is left from previous versions where it would</span>
        <span class="c1"># implement a subset of features which ``_Cache`` has.</span>
        <span class="c1"># It is left for now for backwards compatibility reasons and shall</span>
        <span class="c1"># be deprecated and removed in the future versions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_latest</span><span class="p">:</span> <span class="n">GetLatest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_latest</span> <span class="o">=</span> <span class="n">GetLatest</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ParamDataType</span><span class="p">]</span>
        <span class="n">implements_get_raw</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get_raw&#39;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span><span class="p">,</span>
                            <span class="s1">&#39;__qcodes_is_abstract_method__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gettable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">implements_get_raw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gettable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Overwriting get in a subclass of &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;_BaseParameter: &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">full_name</span><span class="si">}</span><span class="s1"> is not allowed.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">implements_set_raw</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set_raw&#39;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">,</span>
                            <span class="s1">&#39;__qcodes_is_abstract_method__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">implements_set_raw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Overwriting set in a subclass of &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;_BaseParameter: &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">full_name</span><span class="si">}</span><span class="s1"> is not allowed.&#39;</span><span class="p">)</span>

        <span class="c1"># subclasses should extend this list with extra attributes they</span>
        <span class="c1"># want automatically included in the snapshot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;instrument&#39;</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;inter_delay&#39;</span><span class="p">,</span> <span class="s1">&#39;post_delay&#39;</span><span class="p">,</span> <span class="s1">&#39;val_mapping&#39;</span><span class="p">,</span> <span class="s1">&#39;vals&#39;</span><span class="p">]</span>

        <span class="c1"># Specify time of last set operation, used when comparing to delay to</span>
        <span class="c1"># check if additional waiting time is needed before next set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="c1"># should we call validate when getting data. default to False</span>
        <span class="c1"># intended to be changed in a subclass if you want the subclass</span>
        <span class="c1"># to perform a validation on get</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_on_get</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abstract</span> <span class="o">=</span> <span class="n">abstract</span>

        <span class="k">if</span> <span class="n">instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bind_to_instrument</span><span class="p">:</span>
            <span class="n">existing_parameter</span> <span class="o">=</span> <span class="n">instrument</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">existing_parameter</span><span class="p">:</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">existing_parameter</span><span class="o">.</span><span class="n">abstract</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Duplicate parameter name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> on instrument </span><span class="si">{</span><span class="n">instrument</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="n">instrument</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamRawDataType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Note that this property will be deprecated soon. Use</span>
<span class="sd">        ``cache.raw_value`` instead.</span>

<span class="sd">        Represents the cached raw value of the parameter.</span>

<span class="sd">        :getter: Returns the cached raw value of the parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">raw_value</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamRawDataType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``get_raw`` is called to perform the actual data acquisition from the</span>
<span class="sd">        instrument. This method should either be overwritten to perform the</span>
<span class="sd">        desired operation or alternatively for :class:`.Parameter` a</span>
<span class="sd">        suitable method is automatically generated if ``get_cmd`` is supplied</span>
<span class="sd">        to the parameter constructor. The method is automatically wrapped to</span>
<span class="sd">        provide a ``get`` method on the parameter instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">set_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamRawDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``set_raw`` is called to perform the actual setting of a parameter on</span>
<span class="sd">        the instrument. This method should either be overwritten to perform the</span>
<span class="sd">        desired operation or alternatively for :class:`.Parameter` a</span>
<span class="sd">        suitable method is automatically generated if ``set_cmd`` is supplied</span>
<span class="sd">        to the parameter constructor. The method is automatically wrapped to</span>
<span class="sd">        provide a ``set`` method on the parameter instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Include the instrument name with the Parameter name if possible.&quot;&quot;&quot;</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inst_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">inst_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">named_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ParamDataType</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no get cmd found in&#39;</span> <span class="o">+</span>
                                          <span class="sa">f</span><span class="s1">&#39; Parameter </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no set cmd found in&#39;</span> <span class="o">+</span>
                                          <span class="sa">f</span><span class="s1">&#39; Parameter </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">params_to_skip_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        State of the parameter as a JSON-compatible dict (everything that</span>
<span class="sd">        the custom JSON encoder class</span>
<span class="sd">        :class:`qcodes.utils.helpers.NumpyJSONEncoder` supports).</span>

<span class="sd">        If the parameter has been initiated with ``snapshot_value=False``,</span>
<span class="sd">        the snapshot will NOT include the ``value`` and ``raw_value`` of the</span>
<span class="sd">        parameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            update: If True, update the state by calling ``parameter.get()``</span>
<span class="sd">                unless ``snapshot_get`` of the parameter is ``False``.</span>
<span class="sd">                If ``update`` is ``None``, use the current value from the</span>
<span class="sd">                ``cache`` unless the cache is invalid. If ``False``, never call</span>
<span class="sd">                ``parameter.get()``.</span>
<span class="sd">            params_to_skip_update: No effect but may be passed from superclass</span>

<span class="sd">        Returns:</span>
<span class="sd">            base snapshot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_exclude</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Parameter (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">) is used in the snapshot while it &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;should be excluded from the snapshot&quot;</span><span class="p">)</span>

        <span class="n">state</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;__class__&#39;</span><span class="p">:</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                                 <span class="s1">&#39;full_name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span><span class="p">:</span>
            <span class="n">has_get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span>
            <span class="n">allowed_to_call_get_when_snapshotting</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_get</span>
                                                     <span class="ow">and</span> <span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">can_call_get_when_snapshotting</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">allowed_to_call_get_when_snapshotting</span> <span class="ow">and</span> <span class="n">has_get</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">can_call_get_when_snapshotting</span> <span class="ow">and</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">state</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">state</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">get_if_invalid</span><span class="o">=</span><span class="n">can_call_get_when_snapshotting</span><span class="p">)</span>

            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;raw_value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">raw_value</span>

        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">timestamp</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">],</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="n">dttime</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dttime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;instrument&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                    <span class="s1">&#39;instrument&#39;</span><span class="p">:</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">),</span>
                    <span class="s1">&#39;instrument_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="n">name</span>
                <span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">attr_strip</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>  <span class="c1"># strip leading underscores</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Validator</span><span class="p">):</span>
                        <span class="n">state</span><span class="p">[</span><span class="n">attr_strip</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="n">attr_strip</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">snapshot_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If True the value of the parameter will be included in the snapshot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span>

    <span class="k">def</span> <span class="nf">_from_value_to_raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span>
                                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamRawDataType</span><span class="p">:</span>
        <span class="n">raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert set values using val_mapping dictionary</span>
            <span class="n">raw_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_mapping</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raw_value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># transverse transformation in reverse order as compared to</span>
        <span class="c1"># getter: apply scale first</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                <span class="c1"># Scale contains multiple elements, one for each value</span>
                <span class="n">raw_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">*</span> <span class="n">scale</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">scale</span>
                                  <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">raw_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use single scale for all values</span>
                <span class="n">raw_value</span> <span class="o">=</span> <span class="n">raw_value</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

        <span class="c1"># apply offset next</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                <span class="c1"># offset contains multiple elements, one for each value</span>
                <span class="n">raw_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">offset</span>
                                  <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">raw_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use single offset for all values</span>
                <span class="n">raw_value</span> <span class="o">=</span> <span class="n">raw_value</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>

        <span class="c1"># parser last</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_parser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raw_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_parser</span><span class="p">(</span><span class="n">raw_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">raw_value</span>

    <span class="k">def</span> <span class="nf">_from_raw_value_to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span>
                                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parser</span><span class="p">(</span><span class="n">raw_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">raw_value</span>

        <span class="c1"># apply offset first (native scale)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># offset values</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                    <span class="c1"># offset contains multiple elements, one for each value</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">offset</span>
                                  <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                    <span class="c1"># Use single offset for all values</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="c1"># scale second</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Scale values</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                    <span class="c1"># Scale contains multiple elements, one for each value</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">scale</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                    <span class="c1"># Use single scale for all values</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; not in val_mapping&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_wrap_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ParamDataType</span><span class="p">])</span> <span class="o">-&gt;</span>\
            <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ParamDataType</span><span class="p">]:</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">get_function</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Trying to get a parameter&quot;</span>
                                <span class="s2">&quot; that is not gettable.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Trying to get an abstract parameter: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">full_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># There might be cases where a .get also has args/kwargs</span>
                <span class="n">raw_value</span> <span class="o">=</span> <span class="n">get_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_raw_value_to_value</span><span class="p">(</span><span class="n">raw_value</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_on_get</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">_update_with</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">raw_value</span><span class="o">=</span><span class="n">raw_value</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">value</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;getting </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,)</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">get_wrapper</span>

    <span class="k">def</span> <span class="nf">_wrap_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> \
            <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">set_function</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_wrapper</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settable</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Trying to set a parameter&quot;</span>
                                    <span class="s2">&quot; that is not settable.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Trying to set an abstract parameter: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">full_name</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># In some cases intermediate sweep values must be used.</span>
                <span class="c1"># Unless `self.step` is defined, get_sweep_values will return</span>
                <span class="c1"># a list containing only `value`.</span>
                <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ramp_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">step_index</span><span class="p">,</span> <span class="n">val_step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
                    <span class="c1"># even if the final value is valid we may be generating</span>
                    <span class="c1"># steps that are not so validate them too</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">val_step</span><span class="p">)</span>

                    <span class="n">raw_val_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_value_to_raw_value</span><span class="p">(</span><span class="n">val_step</span><span class="p">)</span>

                    <span class="c1"># Check if delay between set operations is required</span>
                    <span class="n">t_elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span>
                    <span class="k">if</span> <span class="n">t_elapsed</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span><span class="p">:</span>
                        <span class="c1"># Sleep until time since last set is larger than</span>
                        <span class="c1"># self.inter_delay</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span> <span class="o">-</span> <span class="n">t_elapsed</span><span class="p">)</span>

                    <span class="c1"># Start timer to measure execution time of set_function</span>
                    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

                    <span class="n">set_function</span><span class="p">(</span><span class="n">raw_val_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                    <span class="c1"># Update last set time (used for calculating delays)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

                    <span class="c1"># Check if any delay after setting is required</span>
                    <span class="n">t_elapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span> <span class="o">-</span> <span class="n">t0</span>
                    <span class="k">if</span> <span class="n">t_elapsed</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_delay</span><span class="p">:</span>
                        <span class="c1"># Sleep until total time is larger than self.post_delay</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">post_delay</span> <span class="o">-</span> <span class="n">t_elapsed</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">_update_with</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">val_step</span><span class="p">,</span>
                                            <span class="n">raw_value</span><span class="o">=</span><span class="n">raw_val_step</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;setting </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,)</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">set_wrapper</span>

    <span class="k">def</span> <span class="nf">get_ramp_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Sized</span><span class="p">],</span>
                        <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Sized</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return values to sweep from current value to target value.</span>
<span class="sd">        This method can be overridden to have a custom sweep behaviour.</span>
<span class="sd">        It can even be overridden by a generator.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: target value</span>
<span class="sd">            step: maximum step size</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of stepped values, including target value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to step a parameter&quot;</span>
                                   <span class="s2">&quot; with more than one value&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_latest</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">start_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_latest</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))):</span>
                <span class="c1"># parameter is numeric but either one of the endpoints</span>
                <span class="c1"># is not or the starting point is unknown. The later</span>
                <span class="c1"># can happen for a non gettable parameter in the initial set</span>
                <span class="c1"># operation.</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot sweep </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> from </span><span class="si">{</span><span class="n">start_value</span><span class="si">!r}</span><span class="s1"> &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;to </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1"> - jumping.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

            <span class="c1"># drop the initial value, we&#39;re already there</span>
            <span class="k">return</span> <span class="n">permissive_range</span><span class="p">(</span><span class="n">start_value</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">step</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the value supplied.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: value to validate</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the value is of the wrong type.</span>
<span class="sd">            ValueError: If the value is outside the bounds specified by the</span>
<span class="sd">               validator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="ow">or</span>
                       <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;Parameter: &#39;</span> <span class="o">+</span> <span class="n">context</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stepsize that this Parameter uses during set operation.</span>
<span class="sd">        Stepsize must be a positive number or None.</span>
<span class="sd">        If step is a positive number, this is the maximum value change</span>
<span class="sd">        allowed in one hardware call, so a single set can result in many</span>
<span class="sd">        calls to the hardware if the starting value is far from the target.</span>
<span class="sd">        All but the final change will attempt to change by +/- step exactly.</span>
<span class="sd">        If step is None stepping will not be used.</span>

<span class="sd">        :getter: Returns the current stepsize.</span>
<span class="sd">        :setter: Sets the value of the step.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if step is set to not numeric or None</span>
<span class="sd">            ValueError: if step is set to negative</span>
<span class="sd">            TypeError:  if step is set to not integer or None for an</span>
<span class="sd">                integer parameter</span>
<span class="sd">            TypeError: if step is set to not a number on None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span>

    <span class="nd">@step</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="s1">&#39;is_numeric&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;you can only step numeric parameters&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;step must be a number&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;step must be positive&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Ints</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;step must be a positive int for an Ints parameter&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">=</span> <span class="n">step</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">post_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delay time after *start* of set operation, for each set.</span>
<span class="sd">        The actual time will not be shorter than this, but may be longer</span>
<span class="sd">        if the underlying set call takes longer.</span>

<span class="sd">        Typically used in conjunction with `step` to create an effective</span>
<span class="sd">        ramp rate, but can also be used without a `step` to enforce a delay</span>
<span class="sd">        *after* every set. One might think of post_delay as how long a set</span>
<span class="sd">        operation is supposed to take. For example, there might be an</span>
<span class="sd">        instrument that needs extra time after setting a parameter although</span>
<span class="sd">        the command for setting the parameter returns quickly.</span>

<span class="sd">        :getter: Returns the current post_delay.</span>
<span class="sd">        :setter: Sets the value of the post_delay.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If delay is not int nor float</span>
<span class="sd">            ValueError: If delay is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_delay</span>

    <span class="nd">@post_delay</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">post_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_delay</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">post_delay</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;post_delay (</span><span class="si">{</span><span class="n">post_delay</span><span class="si">}</span><span class="s1">) must be a number&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">post_delay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;post_delay (</span><span class="si">{</span><span class="n">post_delay</span><span class="si">}</span><span class="s1">) must not be negative&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_delay</span> <span class="o">=</span> <span class="n">post_delay</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inter_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delay time between consecutive set operations.</span>
<span class="sd">        The actual time will not be shorter than this, but may be longer</span>
<span class="sd">        if the underlying set call takes longer.</span>

<span class="sd">        Typically used in conjunction with `step` to create an effective</span>
<span class="sd">        ramp rate, but can also be used without a `step` to enforce a delay</span>
<span class="sd">        *between* sets.</span>

<span class="sd">        :getter: Returns the current inter_delay.</span>
<span class="sd">        :setter: Sets the value of the inter_delay.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If delay is not int nor float</span>
<span class="sd">            ValueError: If delay is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inter_delay</span>

    <span class="nd">@inter_delay</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inter_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_delay</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inter_delay</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;inter_delay (</span><span class="si">{</span><span class="n">inter_delay</span><span class="si">}</span><span class="s1">) must be a number&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inter_delay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;inter_delay (</span><span class="si">{</span><span class="n">inter_delay</span><span class="si">}</span><span class="s1">) must not be negative&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inter_delay</span> <span class="o">=</span> <span class="n">inter_delay</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Name of the parameter. This is identical to :meth:`short_name`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_short_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">short_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Short name of the parameter. This is without the name of the</span>
<span class="sd">        instrument or submodule that the parameter may be bound to. For</span>
<span class="sd">        full name refer to :meth:`full_name`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_short_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Name of the parameter including the name of the instrument and</span>
<span class="sd">        submodule that the parameter may be bound to. The names are separated</span>
<span class="sd">        by underscores, like this: ``instrument_submodule_parameter``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">instrument</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;InstrumentBase&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first instrument that this parameter is bound to.</span>
<span class="sd">        E.g if this is bound to a channel it will return the channel</span>
<span class="sd">        and not the instrument that the channel is bound too. Use</span>
<span class="sd">        :meth:`root_instrument` to get the real instrument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root_instrument</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;InstrumentBase&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fundamental instrument that this parameter belongs too.</span>
<span class="sd">        E.g if the parameter is bound to a channel this will return the</span>
<span class="sd">        fundamental instrument that that channel belongs to. Use</span>
<span class="sd">        :meth:`instrument` to get the channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="n">root_instrument</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">set_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span>
               <span class="n">allow_changes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_SetParamContext</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a context manager to temporarily set a parameter to a value. By</span>
<span class="sd">        default, the parameter value cannot be changed inside the context.</span>
<span class="sd">        This may be overridden with ``allow_changes=True``.</span>

<span class="sd">        Examples:</span>

<span class="sd">            &gt;&gt;&gt; from qcodes import Parameter</span>
<span class="sd">            &gt;&gt;&gt; p = Parameter(&quot;p&quot;, set_cmd=None, get_cmd=None)</span>
<span class="sd">            &gt;&gt;&gt; p.set(2)</span>
<span class="sd">            &gt;&gt;&gt; with p.set_to(3):</span>
<span class="sd">            ...     print(f&quot;p value in with block {p.get()}&quot;)  # prints 3</span>
<span class="sd">            ...     p.set(5)  # raises an exception</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;p value outside with block {p.get()}&quot;)  # prints 2</span>
<span class="sd">            &gt;&gt;&gt; with p.set_to(3, allow_changes=True):</span>
<span class="sd">            ...     p.set(5)  # now this works</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;value after second block: {p.get()}&quot;)  # still prints 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">context_manager</span> <span class="o">=</span> <span class="n">_SetParamContext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                                           <span class="n">allow_changes</span><span class="o">=</span><span class="n">allow_changes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">context_manager</span>

    <span class="k">def</span> <span class="nf">restore_at_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_changes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_SetParamContext</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a context manager to restore the value of a parameter after a</span>
<span class="sd">        ``with`` block.</span>

<span class="sd">        By default, the parameter value may be changed inside the block, but</span>
<span class="sd">        this can be prevented with ``allow_changes=False``. This can be</span>
<span class="sd">        useful, for example, for debugging a complex measurement that</span>
<span class="sd">        unintentionally modifies a parameter.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; p = Parameter(&quot;p&quot;, set_cmd=None, get_cmd=None)</span>
<span class="sd">            &gt;&gt;&gt; p.set(2)</span>
<span class="sd">            &gt;&gt;&gt; with p.restore_at_exit():</span>
<span class="sd">            ...     p.set(3)</span>
<span class="sd">            ...     print(f&quot;value inside with block: {p.get()}&quot;)  # prints 3</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;value after with block: {p.get()}&quot;)  # prints 2</span>
<span class="sd">            &gt;&gt;&gt; with p.restore_at_exit(allow_changes=False):</span>
<span class="sd">            ...     p.set(5)  # raises an exception</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">(),</span> <span class="n">allow_changes</span><span class="o">=</span><span class="n">allow_changes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of the parts that make up the full name of this parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_parts</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;name_parts&#39;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">name_parts</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="c1"># add fallback for the case where someone has bound</span>
                <span class="c1"># the parameter to something that is not an instrument</span>
                <span class="c1"># but perhaps it has a name anyway?</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">name_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_parts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">name_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">short_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name_parts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gettable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is it allowed to call get on this parameter?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gettable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is it allowed to call set on this parameter?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">underlying_instrument</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;InstrumentBase&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an instance of the underlying hardware instrument that this</span>
<span class="sd">        parameter communicates with, per this parameter&#39;s implementation.</span>

<span class="sd">        This is useful in the case where a parameter does not belongs to</span>
<span class="sd">        an instrument instance that represents a real hardware instrument</span>
<span class="sd">        but actually uses a real hardware instrument in its implementation</span>
<span class="sd">        (e.g. via calls to one or more parameters of that real hardware</span>
<span class="sd">        instrument). This is also useful when a parameter does belong to</span>
<span class="sd">        an instrument instance but that instance does not represent the</span>
<span class="sd">        real hardware instrument that the parameter interacts with: hence</span>
<span class="sd">        ``root_instrument`` of the parameter cannot be the</span>
<span class="sd">        ``hardware_instrument``, however ``underlying_instrument`` can be</span>
<span class="sd">        implemented to return the ``hardware_instrument``.</span>

<span class="sd">        By default it returns the ``root_instrument`` of the parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_instrument</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">abstract</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abstract</span>


<div class="viewcode-block" id="Parameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.Parameter">[docs]</a><span class="k">class</span> <span class="nc">Parameter</span><span class="p">(</span><span class="n">_BaseParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parameter represents a single degree of freedom. Most often,</span>
<span class="sd">    this is the standard parameter for Instruments, though it can also be</span>
<span class="sd">    used as a variable, i.e. storing/retrieving a value, or be subclassed for</span>
<span class="sd">    more complex uses.</span>

<span class="sd">    By default only gettable, returning its last value.</span>
<span class="sd">    This behaviour can be modified in two ways:</span>

<span class="sd">    1. Providing a ``get_cmd``/``set_cmd``, which can do the following:</span>

<span class="sd">       a. callable, with zero args for get_cmd, one arg for set_cmd</span>
<span class="sd">       b. VISA command string</span>
<span class="sd">       c. None, in which case it retrieves its last value for ``get_cmd``,</span>
<span class="sd">          and stores a value for ``set_cmd``</span>
<span class="sd">       d. False, in which case trying to get/set will raise an error.</span>

<span class="sd">    2. Creating a subclass with an explicit :meth:`get_raw`/:meth:`set_raw`</span>
<span class="sd">       method.</span>

<span class="sd">       This enables more advanced functionality. The :meth:`get_raw` and</span>
<span class="sd">       :meth:`set_raw` methods are automatically wrapped to provide ``get`` and</span>
<span class="sd">       ``set``.</span>

<span class="sd">    It is an error to do both 1 and 2. E.g supply a ``get_cmd``/``set_cmd``</span>
<span class="sd">    and implement ``get_raw``/``set_raw``</span>


<span class="sd">    To detect if a parameter is gettable or settable check the attributes</span>
<span class="sd">    :py:attr:`~gettable` and :py:attr:`~settable` on the parameter.</span>

<span class="sd">    Parameters have a ``cache`` object that stores internally the current</span>
<span class="sd">    ``value`` and ``raw_value`` of the parameter. Calling ``cache.get()``</span>
<span class="sd">    (or ``cache()``) simply returns the most recent set or measured value of</span>
<span class="sd">    the parameter.</span>

<span class="sd">    Parameter also has a ``.get_latest`` method that duplicates the behavior</span>
<span class="sd">    of ``cache()`` call, as in, it also simply returns the most recent set</span>
<span class="sd">    or measured value.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: The local name of the parameter. Should be a valid</span>
<span class="sd">            identifier, ie no spaces or special characters. If this parameter</span>
<span class="sd">            is part of an Instrument or Station, this is how it will be</span>
<span class="sd">            referenced from that parent, ie ``instrument.name`` or</span>
<span class="sd">            ``instrument.parameters[name]``.</span>

<span class="sd">        instrument: The instrument this parameter</span>
<span class="sd">            belongs to, if any.</span>

<span class="sd">        label: Normally used as the axis label when this</span>
<span class="sd">            parameter is graphed, along with ``unit``.</span>

<span class="sd">        unit: The unit of measure. Use ``&#39;&#39;`` for unitless.</span>

<span class="sd">        snapshot_get: ``False`` prevents any update to the</span>
<span class="sd">            parameter during a snapshot, even if the snapshot was called with</span>
<span class="sd">            ``update=True``, for example, if it takes too long to update,</span>
<span class="sd">            or if the parameter is only meant for measurements hence calling</span>
<span class="sd">            get on it during snapshot may be an error. Default True.</span>

<span class="sd">        snapshot_value: ``False`` prevents parameter value to be</span>
<span class="sd">            stored in the snapshot. Useful if the value is large.</span>

<span class="sd">        snapshot_exclude: ``True`` prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>
<span class="sd">            Default ``False``.</span>

<span class="sd">        step: Max increment of parameter value.</span>
<span class="sd">            Larger changes are broken into multiple steps this size.</span>
<span class="sd">            When combined with delays, this acts as a ramp.</span>

<span class="sd">        scale: Scale to multiply value with before</span>
<span class="sd">            performing set. the internally multiplied value is stored in</span>
<span class="sd">            ``cache.raw_value``. Can account for a voltage divider.</span>

<span class="sd">        inter_delay: Minimum time (in seconds)</span>
<span class="sd">            between successive sets. If the previous set was less than this,</span>
<span class="sd">            it will wait until the condition is met.</span>
<span class="sd">            Can be set to 0 to go maximum speed with no errors.</span>

<span class="sd">        post_delay: Time (in seconds) to wait</span>
<span class="sd">            after the *start* of each set, whether part of a sweep or not.</span>
<span class="sd">            Can be set to 0 to go maximum speed with no errors.</span>

<span class="sd">        val_mapping: A bi-directional map data/readable values</span>
<span class="sd">            to instrument codes, expressed as a dict:</span>
<span class="sd">            ``{data_val: instrument_code}``</span>
<span class="sd">            For example, if the instrument uses &#39;0&#39; to mean 1V and &#39;1&#39; to mean</span>
<span class="sd">            10V, set val_mapping={1: &#39;0&#39;, 10: &#39;1&#39;} and on the user side you</span>
<span class="sd">            only see 1 and 10, never the coded &#39;0&#39; and &#39;1&#39;</span>
<span class="sd">            If vals is omitted, will also construct a matching Enum validator.</span>
<span class="sd">            **NOTE** only applies to get if get_cmd is a string, and to set if</span>
<span class="sd">            set_cmd is a string.</span>
<span class="sd">            You can use ``val_mapping`` with ``get_parser``, in which case</span>
<span class="sd">            ``get_parser`` acts on the return value from the instrument first,</span>
<span class="sd">            then ``val_mapping`` is applied (in reverse).</span>

<span class="sd">        get_parser: Function to transform the response</span>
<span class="sd">            from get to the final output value. See also `val_mapping`.</span>

<span class="sd">        set_parser: Function to transform the input set</span>
<span class="sd">            value to an encoded value sent to the instrument.</span>
<span class="sd">            See also `val_mapping`.</span>

<span class="sd">        vals: Allowed values for setting this parameter.</span>
<span class="sd">            Only relevant if settable. Defaults to ``Numbers()``.</span>

<span class="sd">        max_val_age: The max time (in seconds) to trust a</span>
<span class="sd">            saved value obtained from ``cache()`` (or ``cache.get()``, or</span>
<span class="sd">            ``get_latest()``. If this parameter has not been set or measured</span>
<span class="sd">            more recently than this, perform an additional measurement.</span>

<span class="sd">        initial_value: Value to set the parameter to at the end of its</span>
<span class="sd">            initialization (this is equivalent to calling</span>
<span class="sd">            ``parameter.set(initial_value)`` after parameter initialization).</span>
<span class="sd">            Cannot be passed together with ``initial_cache_value`` argument.</span>

<span class="sd">        initial_cache_value: Value to set the cache of the parameter to</span>
<span class="sd">            at the end of its initialization (this is equivalent to calling</span>
<span class="sd">            ``parameter.cache.set(initial_cache_value)`` after parameter</span>
<span class="sd">            initialization). Cannot be passed together with ``initial_value``</span>
<span class="sd">            argument.</span>

<span class="sd">        docstring: Documentation string for the ``__doc__``</span>
<span class="sd">            field of the object. The ``__doc__``  field of the instance is</span>
<span class="sd">            used by some help systems, but not all.</span>

<span class="sd">        metadata: Extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter.</span>

<span class="sd">        abstract: Specifies if this parameter is abstract or not. Default</span>
<span class="sd">            is False. If the parameter is &#39;abstract&#39;, it *must* be overridden</span>
<span class="sd">            by a non-abstract parameter before the instrument containing</span>
<span class="sd">            this parameter can be instantiated. We override a parameter by</span>
<span class="sd">            adding one with the same name and unit. An abstract parameter</span>
<span class="sd">            can be added in a base class and overridden in a subclass.</span>

<span class="sd">        bind_to_instrument: Should the parameter be registered as a delegate attribute</span>
<span class="sd">            on the instrument passed via the instrument argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;InstrumentBase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">get_cmd</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">set_cmd</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">initial_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_val_age</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Validator</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">docstring</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">initial_cache_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bind_to_instrument</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bind_to_instrument</span><span class="p">:</span>
            <span class="n">existing_parameter</span> <span class="o">=</span> <span class="n">instrument</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">existing_parameter</span><span class="p">:</span>

                <span class="c1"># this check is redundant since its also in the baseclass</span>
                <span class="c1"># but if we do not put it here it would be an api break</span>
                <span class="c1"># as parameter duplication check won&#39;t be done first,</span>
                <span class="c1"># hence for parameters that are duplicates and have</span>
                <span class="c1"># wrong units, users will be getting ValueError where</span>
                <span class="c1"># they used to have KeyError before.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">existing_parameter</span><span class="o">.</span><span class="n">abstract</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Duplicate parameter name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> on instrument </span><span class="si">{</span><span class="n">instrument</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="n">existing_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">existing_parameter</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">existing_unit</span> <span class="o">!=</span> <span class="n">unit</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The unit of the parameter &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;This is inconsistent with the unit defined in the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;base class&quot;</span>
                    <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">,</span>
            <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span>
            <span class="n">max_val_age</span><span class="o">=</span><span class="n">max_val_age</span><span class="p">,</span>
            <span class="n">bind_to_instrument</span><span class="o">=</span><span class="n">bind_to_instrument</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">no_instrument_get</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span> <span class="ow">and</span> \
            <span class="p">(</span><span class="n">get_cmd</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">get_cmd</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># TODO: a matching check should be in _BaseParameter but</span>
        <span class="c1">#   due to the current limited design the _BaseParameter cannot</span>
        <span class="c1">#   know if this subclass will supply a get_cmd</span>
        <span class="c1">#   To work around this a RunTime check is put into get of GetLatest</span>
        <span class="c1">#   and into get of _Cache</span>
        <span class="k">if</span> <span class="n">max_val_age</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">no_instrument_get</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Must have get method or specify get_cmd &#39;</span>
                              <span class="s1">&#39;when max_val_age is set&#39;</span><span class="p">)</span>

        <span class="c1"># Enable set/get methods from get_cmd/set_cmd if given and</span>
        <span class="c1"># no `get`/`set` or `get_raw`/`set_raw` methods have been defined</span>
        <span class="c1"># in the scope of this class.</span>
        <span class="c1"># (previous call to `super().__init__` wraps existing</span>
        <span class="c1"># get_raw/set_raw into get/set methods)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span> <span class="ow">and</span> <span class="n">get_cmd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Supplying a not None or False `get_cmd` to a Parameter&quot;</span>
                            <span class="s2">&quot; that already implements&quot;</span>
                            <span class="s2">&quot; get_raw is an error.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span> <span class="ow">and</span> <span class="n">get_cmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_cmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># type: ignore[assignment]</span>
                    <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">raw_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exec_str_ask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="s2">&quot;ask&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> \
                    <span class="k">if</span> <span class="n">instrument</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="n">arg_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># type: ignore[assignment]</span>
                                       <span class="n">cmd</span><span class="o">=</span><span class="n">get_cmd</span><span class="p">,</span>
                                       <span class="n">exec_str</span><span class="o">=</span><span class="n">exec_str_ask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gettable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settable</span> <span class="ow">and</span> <span class="n">set_cmd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Supplying a not None or False `set_cmd` to a Parameter&quot;</span>
                            <span class="s2">&quot; that already implements&quot;</span>
                            <span class="s2">&quot; set_raw is an error.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settable</span> <span class="ow">and</span> <span class="n">set_cmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">set_cmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exec_str_write</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> \
                    <span class="k">if</span> <span class="n">instrument</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="n">arg_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="o">=</span><span class="n">set_cmd</span><span class="p">,</span>
                                       <span class="n">exec_str</span><span class="o">=</span><span class="n">exec_str_write</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;vals&#39;</span><span class="p">])</span>

        <span class="c1">#: Label of the data used for plots etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span>
        <span class="c1">#: The unit of measure. Use ``&#39;&#39;`` for unitless.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">initial_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">initial_cache_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;It is not possible to specify both of the &#39;</span>
                              <span class="s1">&#39;`initial_value` and `initial_cache_value` &#39;</span>
                              <span class="s1">&#39;keyword arguments.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initial_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initial_cache_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">initial_cache_value</span><span class="p">)</span>

        <span class="c1"># generate default docstring</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
            <span class="s1">&#39;Parameter class:&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;* `name` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;* `label` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="s1">&#39;* `unit` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
            <span class="s1">&#39;* `vals` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                <span class="n">docstring</span><span class="p">,</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

<div class="viewcode-block" id="Parameter.__getitem__"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.Parameter.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SweepFixedValues&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slice a Parameter to get a SweepValues object</span>
<span class="sd">        to iterate over during a sweep</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SweepFixedValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parameter.increment"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.Parameter.increment">[docs]</a>    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Increment the parameter with a value</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Value to be added to the parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parameter.sweep"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.Parameter.sweep">[docs]</a>    <span class="k">def</span> <span class="nf">sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
              <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">num</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SweepFixedValues</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a collection of parameter values to be iterated over.</span>
<span class="sd">        Requires `start` and `stop` and (`step` or `num`)</span>
<span class="sd">        The sign of `step` is not relevant.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: The starting value of the sequence.</span>
<span class="sd">            stop: The end value of the sequence.</span>
<span class="sd">            step:  Spacing between values.</span>
<span class="sd">            num: Number of values to generate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SweepFixedValues: Collection of parameter values to be</span>
<span class="sd">            iterated over.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; sweep(0, 10, num=5)</span>
<span class="sd">             [0.0, 2.5, 5.0, 7.5, 10.0]</span>
<span class="sd">            &gt;&gt;&gt; sweep(5, 10, step=1)</span>
<span class="sd">            [5.0, 6.0, 7.0, 8.0, 9.0, 10.0]</span>
<span class="sd">            &gt;&gt;&gt; sweep(15, 10.5, step=1.5)</span>
<span class="sd">            &gt;[15.0, 13.5, 12.0, 10.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SweepFixedValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                                <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ParameterWithSetpoints"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ParameterWithSetpoints">[docs]</a><span class="k">class</span> <span class="nc">ParameterWithSetpoints</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parameter that has associated setpoints. The setpoints is nothing</span>
<span class="sd">    more than a list of other parameters that describe the values, names</span>
<span class="sd">    and units of the setpoint axis for this parameter.</span>

<span class="sd">    In most cases this will probably be a parameter that returns an array.</span>
<span class="sd">    It is expected that the setpoint arrays are 1D arrays such that the</span>
<span class="sd">    combined shape of the parameter e.g. if parameter is of shape (m,n)</span>
<span class="sd">    `setpoints` is a list of parameters of shape (m,) and (n,)</span>

<span class="sd">    In all other ways this is identical to  :class:`Parameter`. See the</span>
<span class="sd">    documentation of :class:`Parameter` for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Validator</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A ParameterWithSetpoints must have an Arrays &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;validator got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;A ParameterWithSetpoints must have a shape &quot;</span>
                               <span class="s2">&quot;defined for its validator.&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span> <span class="n">snapshot_get</span><span class="o">=</span><span class="n">snapshot_get</span><span class="p">,</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="n">snapshot_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">setpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_on_get</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">setpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sequence of parameters to use as setpoints for this parameter.</span>

<span class="sd">        :getter: Returns a list of parameters currently used for setpoints.</span>
<span class="sd">        :setter: Sets the parameters to be used as setpoints from a sequence.</span>
<span class="sd">            The combined shape of the parameters supplied must be consistent</span>
<span class="sd">            with the data shape of the data returned from get on the parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setpoints</span>

    <span class="nd">@setpoints</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">setpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setpoints</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">setpointarray</span> <span class="ow">in</span> <span class="n">setpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setpointarray</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setpoints is of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">setpointarray</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot; expcected a QCoDeS parameter&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>

<div class="viewcode-block" id="ParameterWithSetpoints.validate_consistent_shape"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ParameterWithSetpoints.validate_consistent_shape">[docs]</a>    <span class="k">def</span> <span class="nf">validate_consistent_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verifies that the shape of the Array Validator of the parameter</span>
<span class="sd">        is consistent with the Validator of the Setpoints. This requires that</span>
<span class="sd">        both the setpoints and the actual parameters have validators</span>
<span class="sd">        of type Arrays with a defined shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can only validate shapes for parameters &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;with Arrays validator. </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> does &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;not have an Arrays validator.&quot;</span><span class="p">)</span>
        <span class="n">output_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span>
        <span class="n">setpoints_shape_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can only validate shapes for parameters &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;with Arrays validator. </span><span class="si">{</span><span class="n">sp</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;a setpoint vector but does not have an &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;Arrays validator&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">setpoints_shape_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">setpoints_shape_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span><span class="p">)</span>
        <span class="n">setpoints_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">setpoints_shape_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying to validate shape but parameter &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> does not define a shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">output_shape</span> <span class="ow">or</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">setpoints_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;One or more dimensions have unknown shape &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;when comparing output: </span><span class="si">{</span><span class="n">output_shape</span><span class="si">}</span><span class="s2"> to &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;setpoints: </span><span class="si">{</span><span class="n">setpoints_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output_shape</span> <span class="o">!=</span> <span class="n">setpoints_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shape of output is not consistent with &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;setpoints. Output is shape </span><span class="si">{</span><span class="n">output_shape</span><span class="si">}</span><span class="s2"> and &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;setpoints are shape </span><span class="si">{</span><span class="n">setpoints_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For parameter </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">full_name</span><span class="si">}</span><span class="s2"> verified &quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;that </span><span class="si">{</span><span class="n">output_shape</span><span class="si">}</span><span class="s2"> matches </span><span class="si">{</span><span class="n">setpoints_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParameterWithSetpoints.validate"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ParameterWithSetpoints.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrites the standard ``validate`` method to also check the the</span>
<span class="sd">        parameter has consistent shape with its setpoints. This only makes</span>
<span class="sd">        sense if the parameter has an Arrays</span>
<span class="sd">        validator</span>

<span class="sd">        Arguments are passed to the super method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent_shape</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DelegateParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.DelegateParameter">[docs]</a><span class="k">class</span> <span class="nc">DelegateParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`.DelegateParameter` wraps a given `source` :class:`Parameter`.</span>
<span class="sd">    Setting/getting it results in a set/get of the source parameter with</span>
<span class="sd">    the provided arguments.</span>

<span class="sd">    The reason for using a :class:`DelegateParameter` instead of the</span>
<span class="sd">    source parameter is to provide all the functionality of the Parameter</span>
<span class="sd">    base class without overwriting properties of the source: for example to</span>
<span class="sd">    set a different scaling factor and unit on the :class:`.DelegateParameter`</span>
<span class="sd">    without changing those in the source parameter.</span>

<span class="sd">    The :class:`DelegateParameter` supports changing the `source`</span>
<span class="sd">    :class:`Parameter`. :py:attr:`~gettable`, :py:attr:`~settable` and</span>
<span class="sd">    :py:attr:`snapshot_value` properties automatically follow the source</span>
<span class="sd">    parameter. If source is set to ``None`` :py:attr:`~gettable` and</span>
<span class="sd">    :py:attr:`~settable` will always be ``False``. It is therefore an error</span>
<span class="sd">    to call get and set on a :class:`DelegateParameter` without a `source`.</span>
<span class="sd">    Note that a parameter without a source can be snapshotted correctly.</span>

<span class="sd">    :py:attr:`.unit` and :py:attr:`.label` can either be set when constructing</span>
<span class="sd">    a :class:`DelegateParameter` or inherited from the source</span>
<span class="sd">    :class:`Parameter`. If inherited they will automatically change when</span>
<span class="sd">    changing the source. Otherwise they will remain fixed.</span>

<span class="sd">    Note:</span>
<span class="sd">        DelegateParameter only supports mappings between the</span>
<span class="sd">        :class:`.DelegateParameter` and :class:`.Parameter` that are invertible</span>
<span class="sd">        (e.g. a bijection). It is therefor not allowed to create a</span>
<span class="sd">        :class:`.DelegateParameter` that performs non invertible</span>
<span class="sd">        transforms in its ``get_raw`` method.</span>

<span class="sd">        A DelegateParameter is not registered on the instrument by default.</span>
<span class="sd">        You should pass ``bind_to_instrument=True`` if you want this to</span>
<span class="sd">        be the case.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_DelegateCache</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">parameter</span><span class="p">:</span> <span class="s1">&#39;DelegateParameter&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span> <span class="o">=</span> <span class="n">parameter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_marked_valid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamRawDataType</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            raw_value is an attribute that surfaces the raw value from the</span>
<span class="sd">            cache. In the case of a :class:`DelegateParameter` it reflects</span>
<span class="sd">            the value of the cache of the source.</span>

<span class="sd">            Strictly speaking it should represent that value independent of</span>
<span class="sd">            its validity according to the `max_val_age` but in fact it does</span>
<span class="sd">            lose its validity when the maximum value age has been reached.</span>
<span class="sd">            This bug will not be fixed since the `raw_value` property will be</span>
<span class="sd">            removed soon.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot get the raw value of a &quot;</span>
                                <span class="s2">&quot;DelegateParameter that delegates to None&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">get_if_invalid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">max_val_age</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">max_val_age</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">timestamp</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">source_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span>
            <span class="k">return</span> <span class="n">source_cache</span><span class="o">.</span><span class="n">valid</span>

        <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_if_invalid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot get the cache of a &quot;</span>
                                <span class="s2">&quot;DelegateParameter that delegates to None&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_from_raw_value_to_value</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">get_if_invalid</span><span class="o">=</span><span class="n">get_if_invalid</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot set the cache of a DelegateParameter &quot;</span>
                                <span class="s2">&quot;that delegates to None&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_from_value_to_raw_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_set_from_raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamRawDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot set the cache of a DelegateParameter &quot;</span>
                                <span class="s2">&quot;that delegates to None&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_update_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                         <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span>
                         <span class="n">raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span><span class="p">,</span>
                         <span class="n">timestamp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This method is needed for interface consistency with ``._Cache``</span>
<span class="sd">            because it is used by ``_BaseParameter`` in</span>
<span class="sd">            ``_wrap_get``/``_wrap_set``. Due to the fact that the source</span>
<span class="sd">            parameter already maintains it&#39;s own cache and the cache of the</span>
<span class="sd">            delegate parameter mirrors the cache of the source parameter by</span>
<span class="sd">            design, this method is just a noop.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">pass</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">get_if_invalid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;bind_to_instrument&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bind_to_instrument&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attr_inherit</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;fixed&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="s2">&quot;value_when_without_source&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">},</span>
                              <span class="s2">&quot;unit&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;fixed&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="s2">&quot;value_when_without_source&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}}</span>

        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attr_props</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_inherit</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">attr_props</span><span class="p">[</span><span class="s2">&quot;fixed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attr_props</span><span class="p">[</span><span class="s2">&quot;fixed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">source_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span>
                                  <span class="n">attr_props</span><span class="p">[</span><span class="s2">&quot;value_when_without_source&quot;</span><span class="p">])</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">source_attr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;set_cmd&#39;</span><span class="p">,</span> <span class="s1">&#39;get_cmd&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;It is not allowed to set &quot;</span><span class="si">{</span><span class="n">cmd</span><span class="si">}</span><span class="s1">&quot; of a &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;DelegateParameter because the one of the &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;source parameter is supposed to be used.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;initial_cache_value&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span>
                               <span class="ow">or</span> <span class="s2">&quot;initial_value&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;It is not allowed to supply &#39;initial_value&#39;&quot;</span>
                           <span class="s2">&quot; or &#39;initial_cache_value&#39; &quot;</span>
                           <span class="s2">&quot;without a source.&quot;</span><span class="p">)</span>

        <span class="n">initial_cache_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;initial_cache_value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># explicitly set the source properties as</span>
        <span class="c1"># init will overwrite the ones set when assigning source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_properties_from_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DelegateCache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_cache_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">initial_cache_value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The source parameter that this :class:`DelegateParameter` is bound to</span>
<span class="sd">        or ``None`` if this  :class:`DelegateParameter` is unbound.</span>

<span class="sd">        :getter: Returns the current source.</span>
<span class="sd">        :setter: Sets the source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span>

    <span class="nd">@source</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Parameter</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_properties_from_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span>

    <span class="k">def</span> <span class="nf">_set_properties_from_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Parameter</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gettable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gettable</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">gettable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settable</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">settable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">_snapshot_value</span>

        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attr_props</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_inherit</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">attr_props</span><span class="p">[</span><span class="s2">&quot;fixed&quot;</span><span class="p">]:</span>
                <span class="n">attr_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span>
                                   <span class="n">attr</span><span class="p">,</span>
                                   <span class="n">attr_props</span><span class="p">[</span><span class="s2">&quot;value_when_without_source&quot;</span><span class="p">])</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attr_val</span><span class="p">)</span>

    <span class="c1"># pylint: disable=method-hidden</span>
<div class="viewcode-block" id="DelegateParameter.get_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.DelegateParameter.get_raw">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot get the value of a DelegateParameter &quot;</span>
                            <span class="s2">&quot;that delegates to a None source.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>

    <span class="c1"># pylint: disable=method-hidden</span>
<div class="viewcode-block" id="DelegateParameter.set_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.DelegateParameter.set_raw">[docs]</a>    <span class="k">def</span> <span class="nf">set_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot set the value of a DelegateParameter &quot;</span>
                            <span class="s2">&quot;that delegates to a None source.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DelegateParameter.snapshot_base"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.DelegateParameter.snapshot_base">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">params_to_skip_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="n">snapshot</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">snapshot_base</span><span class="p">(</span>
            <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">,</span>
            <span class="n">params_to_skip_update</span><span class="o">=</span><span class="n">params_to_skip_update</span>
        <span class="p">)</span>
        <span class="n">source_parameter_snapshot</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span> \
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">snapshot</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">)</span>
        <span class="n">snapshot</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;source_parameter&#39;</span><span class="p">:</span> <span class="n">source_parameter_snapshot</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">snapshot</span></div></div>


<div class="viewcode-block" id="ArrayParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ArrayParameter">[docs]</a><span class="k">class</span> <span class="nc">ArrayParameter</span><span class="p">(</span><span class="n">_BaseParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A gettable parameter that returns an array of values.</span>
<span class="sd">    Not necessarily part of an instrument.</span>

<span class="sd">    For new driver we strongly recommend using</span>
<span class="sd">    :class:`.ParameterWithSetpoints` which is both more flexible and</span>
<span class="sd">    significantly easier to use</span>

<span class="sd">    Subclasses should define a ``.get_raw`` method, which returns an array.</span>
<span class="sd">    This method is automatically wrapped to provide a ``.get`` method.</span>

<span class="sd">    :class:`.ArrayParameter` can be used in both a</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement`</span>
<span class="sd">    as well as in the legacy :class:`qcodes.loops.Loop`</span>
<span class="sd">    and :class:`qcodes.measure.Measure` measurements</span>

<span class="sd">    When used in a ``Loop`` or ``Measure`` operation, this will be entered</span>
<span class="sd">    into a single ``DataArray``, with extra dimensions added by the ``Loop``.</span>
<span class="sd">    The constructor args describe the array we expect from each ``.get`` call</span>
<span class="sd">    and how it should be handled.</span>

<span class="sd">    For now you must specify upfront the array shape, and this cannot change</span>
<span class="sd">    from one call to the next. Later we intend to require only that you specify</span>
<span class="sd">    the dimension, and the size of each dimension can vary from call to call.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: The local name of the parameter. Should be a valid</span>
<span class="sd">            identifier, i.e. no spaces or special characters. If this parameter</span>
<span class="sd">            is part of an ``Instrument`` or ``Station``, this is how it will be</span>
<span class="sd">            referenced from that parent, i.e. ``instrument.name`` or</span>
<span class="sd">            ``instrument.parameters[name]``</span>

<span class="sd">        shape: The shape (as used in numpy arrays) of the array</span>
<span class="sd">            to expect. Scalars should be denoted by (), 1D arrays as (n,),</span>
<span class="sd">            2D arrays as (n, m), etc.</span>

<span class="sd">        instrument: The instrument this parameter</span>
<span class="sd">            belongs to, if any.</span>

<span class="sd">        label: Normally used as the axis label when this</span>
<span class="sd">            parameter is graphed, along with ``unit``.</span>

<span class="sd">        unit: The unit of measure. Use ``&#39;&#39;`` for unitless.</span>

<span class="sd">        setpoints: ``array`` can be a DataArray, numpy.ndarray, or sequence.</span>
<span class="sd">            The setpoints for each dimension of the returned array. An</span>
<span class="sd">            N-dimension item should have N setpoint arrays, where the first is</span>
<span class="sd">            1D, the second 2D, etc.</span>
<span class="sd">            If omitted for any or all items, defaults to integers from zero in</span>
<span class="sd">            each respective direction.</span>
<span class="sd">            **Note**: if the setpoints will be different each measurement,</span>
<span class="sd">            leave this out and return the setpoints (with extra names) in</span>
<span class="sd">            ``.get``.</span>

<span class="sd">        setpoint_names: One identifier (like ``name``) per setpoint array.</span>
<span class="sd">            Ignored if a setpoint is a DataArray, which already has a name.</span>

<span class="sd">        setpoint_labels: One label (like ``labels``) per setpoint array.</span>
<span class="sd">            Ignored if a setpoint is a DataArray, which already has a label.</span>

<span class="sd">        setpoint_units: One unit (like ``v``) per setpoint array. Ignored</span>
<span class="sd">            if a setpoint is a DataArray, which already has a unit.</span>

<span class="sd">        docstring: documentation string for the ``__doc__``</span>
<span class="sd">            field of the object. The ``__doc__`` field of the instance</span>
<span class="sd">            is used by some help systems, but not all.</span>

<span class="sd">        snapshot_get: Prevent any update to the parameter, for example</span>
<span class="sd">            if it takes too long to update. Default ``True``.</span>

<span class="sd">        snapshot_value: Should the value of the parameter be stored in the</span>
<span class="sd">            snapshot. Unlike Parameter this defaults to False as</span>
<span class="sd">            ArrayParameters are potentially huge.</span>

<span class="sd">        snapshot_exclude: ``True`` prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>

<span class="sd">            Default ``False``.</span>

<span class="sd">        metadata: Extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;InstrumentBase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoint_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoint_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoint_units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">docstring</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">snapshot_exclude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">instrument</span><span class="p">,</span>
            <span class="n">snapshot_get</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
            <span class="n">snapshot_value</span><span class="o">=</span><span class="n">snapshot_value</span><span class="p">,</span>
            <span class="n">snapshot_exclude</span><span class="o">=</span><span class="n">snapshot_exclude</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settable</span><span class="p">:</span>
            <span class="c1"># TODO (alexcjohnson): can we support, ala Combine?</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;ArrayParameters do not support set &#39;</span>
                                 <span class="s1">&#39;at this time.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;setpoint_names&#39;</span><span class="p">,</span> <span class="s1">&#39;setpoint_labels&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;setpoint_units&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="n">nt</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shapes must be a tuple of ints, not &#39;</span> <span class="o">+</span>
                             <span class="nb">repr</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="c1"># require one setpoint per dimension of shape</span>
        <span class="n">sp_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),)</span>

        <span class="n">sp_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span>
                    <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoints</span><span class="p">,</span> <span class="n">sp_types</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoints must be a tuple of arrays&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoint_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoint_names</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoint_names must be a tuple of strings&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoint_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoint_labels</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoint_labels must be a tuple of strings&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoint_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoint_units</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoint_units must be a tuple of strings&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="o">=</span> <span class="n">setpoint_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_labels</span> <span class="o">=</span> <span class="n">setpoint_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_units</span> <span class="o">=</span> <span class="n">setpoint_units</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
            <span class="s1">&#39;Parameter class:&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;* `name` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;* `label` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="s1">&#39;* `unit` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
            <span class="s1">&#39;* `shape` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                <span class="n">docstring</span><span class="p">,</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;ArrayParameter must have a get, set or both&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">setpoint_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Full names of setpoints including instrument names if available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># omit the last part of name_parts which is the parameter name</span>
        <span class="c1"># and not part of the setpoint names</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inst_name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">spnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">spname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">spnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">spname</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spnames</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span></div>


<span class="k">def</span> <span class="nf">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
                                <span class="n">types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span>
                                    <span class="n">Type</span><span class="p">[</span><span class="nb">object</span><span class="p">],</span>
                                    <span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="nb">object</span><span class="p">],</span> <span class="o">...</span><span class="p">]]],</span>
                                <span class="n">shapes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span>
                                <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Validator for MultiParameter setpoints/names/labels&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),)):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">obji</span><span class="p">,</span> <span class="n">shapei</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">obji</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shapei</span><span class="p">),)):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="MultiParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.MultiParameter">[docs]</a><span class="k">class</span> <span class="nc">MultiParameter</span><span class="p">(</span><span class="n">_BaseParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A gettable parameter that returns multiple values with separate names,</span>
<span class="sd">    each of arbitrary shape. Not necessarily part of an instrument.</span>

<span class="sd">    Subclasses should define a ``.get_raw`` method, which returns a sequence of</span>
<span class="sd">    values. This method is automatically wrapped to provide a ``.get`` method.</span>
<span class="sd">    When used in a legacy  method``Loop`` or ``Measure`` operation, each of</span>
<span class="sd">    these values will be entered into a different ``DataArray``. The</span>
<span class="sd">    constructor args describe what data we expect from each ``.get`` call</span>
<span class="sd">    and how it should be handled. ``.get`` should always return the same</span>
<span class="sd">    number of items, and most of the constructor arguments should be tuples</span>
<span class="sd">    of that same length.</span>

<span class="sd">    For now you must specify upfront the array shape of each item returned by</span>
<span class="sd">    ``.get_raw``, and this cannot change from one call to the next. Later, we</span>
<span class="sd">    intend to require only that you specify the dimension of each item</span>
<span class="sd">    returned, and the size of each dimension can vary from call to call.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: The local name of the whole parameter. Should be a valid</span>
<span class="sd">            identifier, ie no spaces or special characters. If this parameter</span>
<span class="sd">            is part of an Instrument or Station, this is how it will be</span>
<span class="sd">            referenced from that parent, i.e. ``instrument.name`` or</span>
<span class="sd">            ``instrument.parameters[name]``.</span>

<span class="sd">        names: A name for each item returned by a ``.get``</span>
<span class="sd">            call. Will be used as the basis of the ``DataArray`` names</span>
<span class="sd">            when this parameter is used to create a ``DataSet``.</span>

<span class="sd">        shapes: The shape (as used in numpy arrays) of</span>
<span class="sd">            each item. Scalars should be denoted by (), 1D arrays as (n,),</span>
<span class="sd">            2D arrays as (n, m), etc.</span>

<span class="sd">        instrument: The instrument this parameter</span>
<span class="sd">            belongs to, if any.</span>

<span class="sd">        labels: A label for each item. Normally used</span>
<span class="sd">            as the axis label when a component is graphed, along with the</span>
<span class="sd">            matching entry from ``units``.</span>

<span class="sd">        units: A unit of measure for each item.</span>
<span class="sd">            Use ``&#39;&#39;`` or ``None`` for unitless values.</span>

<span class="sd">        setpoints: ``array`` can be a DataArray, numpy.ndarray, or sequence.</span>
<span class="sd">            The setpoints for each returned array. An N-dimension item should</span>
<span class="sd">            have N setpoint arrays, where the first is 1D, the second 2D, etc.</span>
<span class="sd">            If omitted for any or all items, defaults to integers from zero in</span>
<span class="sd">            each respective direction.</span>
<span class="sd">            **Note**: if the setpoints will be different each measurement,</span>
<span class="sd">            leave this out and return the setpoints (with extra names) in</span>
<span class="sd">            ``.get``.</span>

<span class="sd">        setpoint_names: One identifier (like</span>
<span class="sd">            ``name``) per setpoint array. Ignored if a setpoint is a</span>
<span class="sd">            DataArray, which already has a name.</span>

<span class="sd">        setpoint_labels: One label (like</span>
<span class="sd">            ``labels``) per setpoint array. Ignored if a setpoint is a</span>
<span class="sd">            DataArray, which already has a label.</span>

<span class="sd">        setpoint_units: One unit (like</span>
<span class="sd">            ``V``) per setpoint array. Ignored if a setpoint is a</span>
<span class="sd">            DataArray, which already has a unit.</span>

<span class="sd">        docstring: Documentation string for the ``__doc__``</span>
<span class="sd">            field of the object. The ``__doc__`` field of the  instance is</span>
<span class="sd">            used by some help systems, but not all</span>

<span class="sd">        snapshot_get: Prevent any update to the parameter, for example</span>
<span class="sd">            if it takes too long to update. Default ``True``.</span>

<span class="sd">        snapshot_value: Should the value of the parameter be stored in the</span>
<span class="sd">            snapshot. Unlike Parameter this defaults to False as</span>
<span class="sd">            MultiParameters are potentially huge.</span>

<span class="sd">        snapshot_exclude: True prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>
<span class="sd">            Default ``False``.</span>

<span class="sd">        metadata: Extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;InstrumentBase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoint_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoint_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">setpoint_units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">docstring</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">snapshot_exclude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">instrument</span><span class="p">,</span>
            <span class="n">snapshot_get</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
            <span class="n">snapshot_value</span><span class="o">=</span><span class="n">snapshot_value</span><span class="p">,</span>
            <span class="n">snapshot_exclude</span><span class="o">=</span><span class="n">snapshot_exclude</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;setpoint_names&#39;</span><span class="p">,</span> <span class="s1">&#39;setpoint_labels&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;setpoint_units&#39;</span><span class="p">,</span> <span class="s1">&#39;names&#39;</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;names must be a tuple of strings, not &#39;</span> <span class="o">+</span>
                             <span class="nb">repr</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span> <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="n">nt</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shapes must be a tuple of tuples &#39;</span>
                             <span class="s1">&#39;of ints, not &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span>

        <span class="n">sp_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span>
                    <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoints</span><span class="p">,</span> <span class="n">sp_types</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoints must be a tuple of tuples of arrays&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoint_names</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;setpoint_names must be a tuple of tuples of strings&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoint_labels</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;setpoint_labels must be a tuple of tuples of strings&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoint_units</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;setpoint_units must be a tuple of tuples of strings&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="o">=</span> <span class="n">setpoint_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_labels</span> <span class="o">=</span> <span class="n">setpoint_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_units</span> <span class="o">=</span> <span class="n">setpoint_units</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
            <span class="s1">&#39;MultiParameter class:&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;* `name` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;* `names` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">),</span>
            <span class="s1">&#39;* `labels` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span>
            <span class="s1">&#39;* `units` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                <span class="n">docstring</span><span class="p">,</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gettable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;MultiParameter must have a get, set or both&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">short_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        short_names is identical to names i.e. the names of the parameter</span>
<span class="sd">        parts but does not add the instrument name.</span>

<span class="sd">        It exists for consistency with instruments and other parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Names of the parameter components including the name of the instrument</span>
<span class="sd">        and submodule that the parameter may be bound to. The name parts are</span>
<span class="sd">        separated by underscores, like this: ``instrument_submodule_parameter``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inst_name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">inst_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">setpoint_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Full names of setpoints including instrument names, if available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># omit the last part of name_parts which is the parameter name</span>
        <span class="c1"># and not part of the setpoint names</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inst_name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">full_sp_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sp_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span><span class="p">:</span>
                <span class="n">full_sp_names_subgroupd</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">spname</span> <span class="ow">in</span> <span class="n">sp_group</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">spname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">full_sp_names_subgroupd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">inst_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">spname</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">full_sp_names_subgroupd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">full_sp_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">full_sp_names_subgroupd</span><span class="p">))</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">full_sp_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span></div>


<span class="k">class</span> <span class="nc">_CacheProtocol</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This protocol defines the interface that a Parameter Cache implementation</span>
<span class="sd">    must implement. This is currently used for 2 implementations, one in</span>
<span class="sd">    _BaseParameter and a specialized one in DelegateParameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamRawDataType</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]:</span>
        <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_val_age</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_set_from_raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_if_invalid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_update_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                     <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span>
                     <span class="n">raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span><span class="p">,</span>
                     <span class="n">timestamp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
        <span class="o">...</span>


<span class="k">class</span> <span class="nc">_Cache</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cache object for parameter to hold its value and raw value</span>

<span class="sd">    It also implements ``set`` method for setting parameter&#39;s value without</span>
<span class="sd">    invoking its ``set_cmd``, and ``get`` method that allows to retrieve the</span>
<span class="sd">    cached value of the parameter without calling ``get_cmd`` might be called</span>
<span class="sd">    unless the cache is invalid.</span>

<span class="sd">    Args:</span>
<span class="sd">         parameter: instance of the parameter that this cache belongs to.</span>
<span class="sd">         max_val_age: Max time (in seconds) to trust a value stored in cache.</span>
<span class="sd">            If the parameter has not been set or measured more recently than</span>
<span class="sd">            this, an additional measurement will be performed in order to</span>
<span class="sd">            update the cached value. If it is ``None``, this behavior is</span>
<span class="sd">            disabled. ``max_val_age`` should not be used for a parameter</span>
<span class="sd">            that does not have a get function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">parameter</span><span class="p">:</span> <span class="s1">&#39;_BaseParameter&#39;</span><span class="p">,</span>
                 <span class="n">max_val_age</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span> <span class="o">=</span> <span class="n">parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">:</span> <span class="n">ParamDataType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_val_age</span> <span class="o">=</span> <span class="n">max_val_age</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_marked_valid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamRawDataType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Raw value of the parameter&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Timestamp of the moment when cache was last updated</span>

<span class="sd">        If ``None``, the cache hasn&#39;t been updated yet and shall be seen as</span>
<span class="sd">        &quot;invalid&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_val_age</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Max time (in seconds) to trust a value stored in cache. If the</span>
<span class="sd">        parameter has not been set or measured more recently than this,</span>
<span class="sd">        perform an additional measurement.</span>

<span class="sd">        If it is ``None``, this behavior is disabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_val_age</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the cache is expected be be valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp_expired</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_valid</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call this method to mark the cache invalid.</span>
<span class="sd">        If the cache is invalid the next call to `cache.get()` attempt</span>
<span class="sd">        to get the value from the instrument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_marked_valid</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the cached value of the parameter without invoking the</span>
<span class="sd">        ``set_cmd`` of the parameter (if it has one). For example, in case of</span>
<span class="sd">        an instrument parameter, calling :meth:`cache.set` as opposed to</span>
<span class="sd">        calling ``set`` will only change the internally-stored value of</span>
<span class="sd">        the parameter (that is available when calling ``cache.get()`` or</span>
<span class="sd">        ``get_latest()``), and will NOT pass that value to the instrument.</span>

<span class="sd">        Note that this method also respects all the validation, parsing,</span>
<span class="sd">        offsetting, etc that the parameter&#39;s ``set`` method respects. However,</span>
<span class="sd">        if the parameter has :attr:`step` defined, unlike the ``set`` method,</span>
<span class="sd">        this method does not perform setting the parameter step-by-step.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: new value for the parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">raw_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_from_value_to_raw_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_with</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">raw_value</span><span class="o">=</span><span class="n">raw_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_from_raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_from_raw_value_to_value</span><span class="p">(</span><span class="n">raw_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_validate_on_get</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_with</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">raw_value</span><span class="o">=</span><span class="n">raw_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                     <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span>
                     <span class="n">raw_value</span><span class="p">:</span> <span class="n">ParamRawDataType</span><span class="p">,</span>
                     <span class="n">timestamp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simply overwrites the value, raw value, and timestamp in this cache</span>
<span class="sd">        with new ones.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: new value of the parameter</span>
<span class="sd">            raw_value: new raw value of the parameter</span>
<span class="sd">            timestamp: new timestamp of the parameter; if ``None``,</span>
<span class="sd">                then timestamp of &quot;now&quot; is used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_value</span> <span class="o">=</span> <span class="n">raw_value</span>
        <span class="k">if</span> <span class="n">timestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_marked_valid</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_timestamp_expired</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># parameter has never been captured</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_val_age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># parameter cannot expire</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">oldest_accepted_timestamp</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_val_age</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">&lt;</span> <span class="n">oldest_accepted_timestamp</span><span class="p">:</span>
            <span class="c1"># Time of last get exceeds max_val_age seconds, need to</span>
            <span class="c1"># perform new .get()</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># parameter is still valid</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_if_invalid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cached value if time since get was less than ``max_val_age``,</span>
<span class="sd">        or the parameter was explicitly marked invalid.</span>
<span class="sd">        Otherwise perform ``get()`` on the parameter and return result. A</span>
<span class="sd">        ``get()`` will also be performed if the parameter has never been</span>
<span class="sd">        captured but only if ``get_if_invalid`` argument is ``True``.</span>

<span class="sd">        Args:</span>
<span class="sd">            get_if_invalid: if set to ``True``, ``get()`` on a parameter</span>
<span class="sd">                will be performed in case the cached value is invalid (for</span>
<span class="sd">                example, due to ``max_val_age``, because the parameter has</span>
<span class="sd">                never been captured, or because the parameter was marked</span>
<span class="sd">                invalid)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gettable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">gettable</span>
        <span class="n">cache_valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span>

        <span class="k">if</span> <span class="n">cache_valid</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_if_invalid</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gettable</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_error_msg</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="nf">_construct_error_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value of parameter &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">full_name</span><span class="si">}</span><span class="s2"> &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;is unknown and the Parameter &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;does not have a get command. &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;Please set the value before &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;attempting to get it.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_val_age</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: this check should really be at the time</span>
            <span class="c1">#  of setting max_val_age unfortunately this</span>
            <span class="c1">#  happens in init before get wrapping is performed.</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;`max_val_age` is not supported &quot;</span>
                         <span class="s2">&quot;for a parameter without get &quot;</span>
                         <span class="s2">&quot;command.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># max_val_age is None and TS is not None but cache is</span>
            <span class="c1"># invalid with the current logic that should never</span>
            <span class="c1"># happen</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot return cache of a parameter &quot;</span>
                         <span class="s2">&quot;that does not have a get command &quot;</span>
                         <span class="s2">&quot;and has an invalid cache&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error_msg</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as :meth:`get` but always call ``get`` on parameter if the</span>
<span class="sd">        cache is not valid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">get_if_invalid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="GetLatest"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.GetLatest">[docs]</a><span class="k">class</span> <span class="nc">GetLatest</span><span class="p">(</span><span class="n">DelegateAttributes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for a class:`.Parameter` that just returns the last set or measured</span>
<span class="sd">    value stored in the class:`.Parameter` itself. If get has never been called</span>
<span class="sd">    on the parameter or the time since get was called is larger than</span>
<span class="sd">    ``max_val_age``, get will be called on the parameter. If the parameter</span>
<span class="sd">    does not implement get, set should be called (or the initial_value set)</span>
<span class="sd">    before calling get on this wrapper. It is an error to set</span>
<span class="sd">    ``max_val_age`` for a parameter that does not have a get function.</span>

<span class="sd">    The functionality of this class is subsumed and improved in</span>
<span class="sd">    parameter&#39;s cache that is accessible via ``.cache`` attribute of the</span>
<span class="sd">    :class:`.Parameter`. Use of ``parameter.cache`` is recommended over use of</span>
<span class="sd">    ``parameter.get_latest``.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Can be called:</span>
<span class="sd">        &gt;&gt;&gt; param.get_latest()</span>
<span class="sd">        &gt;&gt;&gt; # Or used as if it were a gettable-only parameter itself:</span>
<span class="sd">        &gt;&gt;&gt; Loop(...).each(param.get_latest)</span>

<span class="sd">    Args:</span>
<span class="sd">        parameter: Parameter to be wrapped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">:</span> <span class="n">_BaseParameter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span> <span class="o">=</span> <span class="n">parameter</span>

    <span class="n">delegate_attr_objects</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span>
    <span class="n">omit_delegate_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="GetLatest.get"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.GetLatest.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return latest value if time since get was less than</span>
<span class="sd">        `max_val_age`, otherwise perform `get()` and</span>
<span class="sd">        return result. A `get()` will also be performed if the</span>
<span class="sd">        parameter never has been captured.</span>

<span class="sd">        It is recommended to use ``parameter.cache.get()`` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>

<div class="viewcode-block" id="GetLatest.get_timestamp"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.GetLatest.get_timestamp">[docs]</a>    <span class="k">def</span> <span class="nf">get_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the age of the latest parameter value.</span>

<span class="sd">        It is recommended to use ``parameter.cache.timestamp`` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">timestamp</span></div>

<div class="viewcode-block" id="GetLatest.get_raw_value"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.GetLatest.get_raw_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ParamRawDataType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return latest raw value of the parameter.</span>

<span class="sd">        It is recommended to use ``parameter.cache.raw_value`` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">_raw_value</span></div>

<div class="viewcode-block" id="GetLatest.__call__"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.GetLatest.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as ``get()``</span>

<span class="sd">        It is recommended to use ``parameter.cache()`` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="combine"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.combine">[docs]</a><span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="o">*</span><span class="n">parameters</span><span class="p">:</span> <span class="s1">&#39;Parameter&#39;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">aggregator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;CombinedParameter&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine parameters into one sweepable parameter</span>

<span class="sd">    A combined parameter sets all the combined parameters at every point</span>
<span class="sd">    of the sweep. The sets are called in the same order the parameters are,</span>
<span class="sd">    and sequentially.</span>

<span class="sd">    Args:</span>
<span class="sd">        *parameters: The parameters to combine.</span>
<span class="sd">        name: The name of the paramter.</span>
<span class="sd">        label: The label of the combined parameter.</span>
<span class="sd">        unit: the unit of the combined parameter.</span>
<span class="sd">        aggregator: a function to aggregate</span>
<span class="sd">            the set values into one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">my_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
    <span class="n">multi_par</span> <span class="o">=</span> <span class="n">CombinedParameter</span><span class="p">(</span><span class="n">my_parameters</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                                  <span class="n">aggregator</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">multi_par</span></div>


<div class="viewcode-block" id="CombinedParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.CombinedParameter">[docs]</a><span class="k">class</span> <span class="nc">CombinedParameter</span><span class="p">(</span><span class="n">Metadatable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A combined parameter. It sets all the combined parameters at every</span>
<span class="sd">    point of the sweep. The sets are called in the same order</span>
<span class="sd">    the parameters are, and sequentially.</span>

<span class="sd">    Args:</span>
<span class="sd">        *parameters: The parameters to combine.</span>
<span class="sd">        name: The name of the parameter</span>
<span class="sd">        label: The label of the combined parameter</span>
<span class="sd">        unit: The unit of the combined parameter</span>
<span class="sd">        aggregator: A function to aggregate the set values into one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">aggregator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># TODO(giulioungaretti)temporary hack</span>
        <span class="c1"># starthack</span>
        <span class="c1"># this is a dummy parameter</span>
        <span class="c1"># that mimicks the api that a normal parameter has</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter name must be a valid identifier &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> which is not. Parameter names &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;cannot start with a number and &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;must not contain spaces or special characters&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
        <span class="c1"># mypy will complain that a callable does not have these attributes</span>
        <span class="c1"># but you can still create them here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">full_name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>  <span class="c1"># type: ignore[attr-defined]</span>

        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warn_units</span><span class="p">(</span><span class="s1">&#39;CombinedParameter&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># endhack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameter</span><span class="o">.</span><span class="n">set</span> <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aggregator</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">aggregator</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">)</span>

<div class="viewcode-block" id="CombinedParameter.set"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.CombinedParameter.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set multiple parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            index: the index of the setpoints one wants to set</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of values that where actually set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">setFunction</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">setFunction</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="CombinedParameter.sweep"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.CombinedParameter.sweep">[docs]</a>    <span class="k">def</span> <span class="nf">sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">array</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;CombinedParameter&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new combined parameter to be iterated over.</span>
<span class="sd">        One can sweep over either:</span>

<span class="sd">         - n array of length m</span>
<span class="sd">         - one nxm array</span>

<span class="sd">        where n is the number of combined parameters</span>
<span class="sd">        and m is the number of setpoints</span>

<span class="sd">        Args:</span>
<span class="sd">            *array: Array(s) of setpoints.</span>

<span class="sd">        Returns:</span>
<span class="sd">            combined parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if it&#39;s a list of arrays, convert to one array</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">array</span><span class="p">}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arrays have different number of setpoints&#39;</span><span class="p">)</span>
            <span class="n">nparray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cast to array in case users</span>
            <span class="c1"># decide to not read docstring</span>
            <span class="c1"># and pass a 2d list</span>
            <span class="n">nparray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_error_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot; Dimensionality of array does not match</span><span class="se">\</span>
<span class="s2">                        the number of parameter combined. Expected a </span><span class="se">\</span>
<span class="s2">                        </span><span class="si">{}</span><span class="s2"> dimensional array, got a </span><span class="si">{}</span><span class="s2"> dimensional array. </span><span class="se">\</span>
<span class="s2">                        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nparray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_error_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">,</span>
                                                   <span class="n">nparray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># this means the array is 1d</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_error_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">new</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">nparray</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new</span></div>

    <span class="k">def</span> <span class="nf">_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="c1"># check f args</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># dimension of the sweep_values</span>
        <span class="c1"># i.e. how many setpoint</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="CombinedParameter.snapshot_base"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.CombinedParameter.snapshot_base">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">params_to_skip_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        State of the combined parameter as a JSON-compatible dict (everything</span>
<span class="sd">        that the custom JSON encoder class</span>
<span class="sd">        :class:`qcodes.utils.helpers.NumpyJSONEncoder` supports).</span>

<span class="sd">        Args:</span>
<span class="sd">            update: ``True`` or ``False``.</span>
<span class="sd">            params_to_skip_update: Unused in this subclass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Base snapshot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;__class__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">unit</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">label</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;full_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">full_name</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;aggregator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">parameter</span><span class="p">)]</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">snapshot</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">meta_data</span></div></div>


<div class="viewcode-block" id="InstrumentRefParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.InstrumentRefParameter">[docs]</a><span class="k">class</span> <span class="nc">InstrumentRefParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instrument reference parameter.</span>

<span class="sd">    This parameter is useful when one needs a reference to another instrument</span>
<span class="sd">    from within an instrument, e.g., when creating a meta instrument that</span>
<span class="sd">    sets parameters on instruments it contains.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: The name of the parameter that one wants to add.</span>

<span class="sd">        instrument: The &quot;parent&quot; instrument this</span>
<span class="sd">            parameter is attached to, if any.</span>

<span class="sd">        initial_value: Starting value, may be None even if None does not</span>
<span class="sd">            pass the validator. None is only allowed as an initial value</span>
<span class="sd">            and cannot be set after initiation.</span>

<span class="sd">        **kwargs: Passed to InstrumentRefParameter parent class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;InstrumentBase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">get_cmd</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">set_cmd</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_val_age</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Validator</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">docstring</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">Strings</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">set_cmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;InstrumentRefParameter does not support &quot;</span>
                               <span class="s2">&quot;set_cmd.&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">get_cmd</span><span class="p">,</span> <span class="n">set_cmd</span><span class="p">,</span>
                         <span class="n">initial_value</span><span class="p">,</span> <span class="n">max_val_age</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">docstring</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># TODO(nulinspiratie) check class works now it&#39;s subclassed from Parameter</span>
<div class="viewcode-block" id="InstrumentRefParameter.get_instr"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.InstrumentRefParameter.get_instr">[docs]</a>    <span class="k">def</span> <span class="nf">get_instr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;InstrumentBase&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the instance of the instrument with the name equal to the</span>
<span class="sd">        value of this parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_instrument_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c1"># note that _instrument refers to the instrument this parameter belongs</span>
        <span class="c1"># to, while the ref_instrument_name is the instrument that is the value</span>
        <span class="c1"># of this parameter.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;InstrumentRefParameter is not bound to &quot;</span>
                               <span class="s2">&quot;an instrument.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="n">find_instrument</span><span class="p">(</span><span class="n">ref_instrument_name</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ManualParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ManualParameter">[docs]</a><span class="k">class</span> <span class="nc">ManualParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;InstrumentBase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A simple alias for a parameter that does not have a set or</span>
<span class="sd">        a get function. Useful for parameters that do not have a direct</span>
<span class="sd">        instrument mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">,</span>
                         <span class="n">get_cmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">set_cmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">initial_value</span><span class="o">=</span><span class="n">initial_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ScaledParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ScaledParameter">[docs]</a><span class="k">class</span> <span class="nc">ScaledParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`.Parameter` Scaler</span>

<span class="sd">    To be used when you use a physical voltage divider or an amplifier to set</span>
<span class="sd">    or get a quantity.</span>

<span class="sd">    Initialize the parameter by passing the parameter to be measured/set</span>
<span class="sd">    and the value of the division OR the gain.</span>

<span class="sd">    The scaling value can be either a scalar value or a Qcodes Parameter.</span>

<span class="sd">    The parameter scaler acts a your original parameter, but will set the right</span>
<span class="sd">    value, and store the gain/division in the metadata.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Resistive voltage divider</span>
<span class="sd">        &gt;&gt;&gt; vd = ScaledParameter(dac.chan0, division = 10)</span>

<span class="sd">        Voltage multiplier</span>
<span class="sd">        &gt;&gt;&gt; vb = ScaledParameter(dac.chan0, gain = 30, name = &#39;Vb&#39;)</span>

<span class="sd">        Transimpedance amplifier</span>
<span class="sd">        &gt;&gt;&gt; Id = ScaledParameter(multimeter.amplitude,</span>
<span class="sd">        ...                      division = 1e6, name = &#39;Id&#39;, unit = &#39;A&#39;)</span>

<span class="sd">    Args:</span>
<span class="sd">        output: Physical Parameter that need conversion.</span>
<span class="sd">        division: The division value.</span>
<span class="sd">        gain: The gain value.</span>
<span class="sd">        label: Label of this parameter, by default uses &#39;output&#39; label</span>
<span class="sd">            but attaches _amplified or _attenuated depending if gain</span>
<span class="sd">            or division has been specified.</span>
<span class="sd">        name: Name of this parameter, by default uses &#39;output&#39; name</span>
<span class="sd">            but attaches _amplified or _attenuated depending if gain</span>
<span class="sd">            or division has been specified.</span>
<span class="sd">        unit: Resulting unit. It uses the one of &#39;output&#39; by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ScaledParameter.Role"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ScaledParameter.Role">[docs]</a>    <span class="k">class</span> <span class="nc">Role</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
        <span class="n">GAIN</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
        <span class="n">DIVISION</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">output</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span>
                 <span class="n">division</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">gain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># Set label</span>
        <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">elif</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2">_scaled&quot;</span>

        <span class="c1"># Set the name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_scaled&quot;</span>

        <span class="c1"># Set the unit</span>
        <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">unit</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span> <span class="o">=</span> <span class="n">output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_instrument</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s2">&quot;_instrument&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Set the role, either as divider or amplifier</span>
        <span class="c1"># Raise an error if nothing is specified</span>
        <span class="n">is_divider</span> <span class="o">=</span> <span class="n">division</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">is_amplifier</span> <span class="o">=</span> <span class="n">gain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">xor</span><span class="p">(</span><span class="n">is_divider</span><span class="p">,</span> <span class="n">is_amplifier</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provide only division OR gain&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">division</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span>
            <span class="c1"># Unfortunately mypy does not support</span>
            <span class="c1"># properties where the setter has different types than</span>
            <span class="c1"># the actual property. We use that here to cast different inputs</span>
            <span class="c1"># to the same type.</span>
            <span class="c1"># https://github.com/python/mypy/issues/3004</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">division</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="k">elif</span> <span class="n">gain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">gain</span>  <span class="c1"># type: ignore[assignment]</span>

        <span class="c1"># extend metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;division&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;gain&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;role&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;wrapped_parameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_instrument</span><span class="p">:</span>
            <span class="n">wrapped_instr_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_instrument</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;wrapped_instrument&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapped_instr_name</span>

    <span class="c1"># Internal handling of the multiplier</span>
    <span class="c1"># can be either a Parameter or a scalar</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parameter</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot get multiplier when multiplier &quot;</span>
                               <span class="s2">&quot;parameter in unknown.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span>

    <span class="nd">@_multiplier</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multiplier</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span> <span class="o">=</span> <span class="n">multiplier</span>
            <span class="n">multiplier_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span><span class="o">.</span><span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;variable_multiplier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">multiplier_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span> <span class="o">=</span> <span class="n">ManualParameter</span><span class="p">(</span>
                <span class="s1">&#39;multiplier&#39;</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="n">multiplier</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;variable_multiplier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Division of the scaler</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">division</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>  <span class="c1"># type: ignore[return]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">value</span>

    <span class="nd">@division</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">division</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">division</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">division</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="c1"># Gain of the scaler</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>   <span class="c1"># type: ignore[return]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">value</span>

    <span class="nd">@gain</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">gain</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="c1"># Getter and setter for the real value</span>
<div class="viewcode-block" id="ScaledParameter.get_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ScaledParameter.get_raw">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            value at which was set at the sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wrapped_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="p">())</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">wrapped_value</span> <span class="o">*</span> <span class="n">multiplier</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">wrapped_value</span> <span class="o">/</span> <span class="n">multiplier</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ScaledParameter must be either a&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;Multiplier or Divisor; got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">role</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">wrapped_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parameter</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The attached unscaled parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span>

<div class="viewcode-block" id="ScaledParameter.get_wrapped_parameter_value"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ScaledParameter.get_wrapped_parameter_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_wrapped_parameter_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            value at which the attached parameter is (i.e. does</span>
<span class="sd">            not account for the scaling)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>

<div class="viewcode-block" id="ScaledParameter.set_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.ScaledParameter.set_raw">[docs]</a>    <span class="k">def</span> <span class="nf">set_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value on the wrapped parameter, accounting for the scaling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">multiplier_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="n">instrument_value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="n">multiplier_value</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="n">instrument_value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">multiplier_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ScaledParameter must be either a&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;Multiplier or Divisor; got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">role</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">instrument_value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="expand_setpoints_helper"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument.parameter.expand_setpoints_helper">[docs]</a><span class="k">def</span> <span class="nf">expand_setpoints_helper</span><span class="p">(</span><span class="n">parameter</span><span class="p">:</span> <span class="n">ParameterWithSetpoints</span><span class="p">,</span>
                            <span class="n">results</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ParamDataType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">,</span> <span class="n">ParamDataType</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function that takes a :class:`.ParameterWithSetpoints` and</span>
<span class="sd">    acquires the parameter along with it&#39;s setpoints. The data is returned</span>
<span class="sd">    in a format prepared to insert into the dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        parameter: A :class:`.ParameterWithSetpoints` to be acquired and</span>
<span class="sd">            expanded</span>
<span class="sd">        results: The data for the given parameter. Typically the output of</span>
<span class="sd">            `parameter.get()`. If None this function will call `parameter.get`</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of tuples of parameters and values for the specified parameter</span>
<span class="sd">        and its setpoints.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">ParameterWithSetpoints</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expanding setpoints only works for ParameterWithSetpoints. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Supplied a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">setpoint_params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">setpoint_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">setpointparam</span> <span class="ow">in</span> <span class="n">parameter</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span>
        <span class="n">these_setpoints</span> <span class="o">=</span> <span class="n">setpointparam</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">setpoint_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setpointparam</span><span class="p">)</span>
        <span class="n">setpoint_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">these_setpoints</span><span class="p">)</span>
    <span class="n">output_grids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">setpoint_data</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">setpoint_params</span><span class="p">,</span> <span class="n">output_grids</span><span class="p">):</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param</span><span class="p">,</span> <span class="n">grid</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">results</span>
    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parameter</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>